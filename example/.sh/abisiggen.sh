#!/bin/bash
#
# abisiggen.sh - Smart Contract Interface Generator
#
# Description:
#   Streamlines Ethereum development by automatically generating:
#   - Event topic hashes and signatures
#   - Method selectors with ABI encoding
#   - Lowercase method names for CLI integration
#   - Ready-to-use initialization functions
#   - Comprehensive contract documentation
#
#   Designed for Go Ethereum projects, this tool parses ABIs to create type-safe
#   accessors that prevent signature mismatches and simplify event filtering.
#
# Usage:
#   ./abisiggen.sh
#
# Requirements:
#   - abigen (Go Ethereum's contract binding generator)
#   - jq (JSON processor for ABI parsing)
#   - cast (Foundry's EVM toolkit for keccak hashing)
#   - awk (Text processing for method extraction)
#
# Generated Output (per contract):
#   [contract]_extra.go - Go structs with topics/methods and initializers
#   [contract]_help.md - Markdown documentation of events and views
#
# Author: rmsrob
# License: MIT
#
# Benefits:
#   - Reduces human error in manual signature calculation
#   - Accelerates integration testing
#   - Maintains consistency across contract versions
#   - Generates audit-ready documentation

# Find all directories in the contract sources directory
# you can edit this to hardcode the contracts you want to process
PROJECT_ROOT="$(dirname "$(dirname "$(realpath "$0")")")"
CONTRACT_SOURCES_DIR="$PROJECT_ROOT/pkg/contracts"

tmpfile=$(mktemp) && find "$CONTRACT_SOURCES_DIR" -mindepth 1 -maxdepth 1 -type d -print0 >"$tmpfile"
unset a i
while IFS= read -r -d '' dir; do
	a[i++]="$(basename "$dir")"
done <"$tmpfile"
rm -f "$tmpfile"
ALL_CONTRACTS=("${a[@]}")

####################################################################
### *** Dependencies MUST generate GO bindings for each contract ***
####################################################################
for CONTRACT in "${ALL_CONTRACTS[@]}"; do
	CONTRACT_DIR="$CONTRACT_SOURCES_DIR/$CONTRACT"
	OUTPUT_FILE="${CONTRACT_DIR}/${CONTRACT}_extra.go"
	OUTPUT_MD_FILE="${CONTRACT_DIR}/${CONTRACT}_help.md"

	# Check ABI exists before any processing
	if [ ! -f "$CONTRACT_DIR/$CONTRACT.abi" ]; then
		echo "❌ Abort: Required ABI not found at $CONTRACT_DIR/$CONTRACT.abi"
		echo "         Generate with 'forge inspect $CONTRACT abi > $CONTRACT.abi'"
		continue
	fi

	echo "Processing $CONTRACT with abigen"

	# Generate bindings first
	abigen --abi="$CONTRACT_DIR/$CONTRACT.abi" \
		--pkg="${CONTRACT}" \
		--out="$CONTRACT_DIR/$CONTRACT.go"

	echo "✓ Generated $CONTRACT bindings"

	# Create contract-specific files
	{
		echo "// Code generated by abisiggen.sh for $CONTRACT; DO NOT EDIT."
		echo "package ${CONTRACT}"
		echo ""
		echo "import ("
		echo "    \"github.com/ethereum/go-ethereum/common\""
		echo ")"
		echo ""
		echo ""
	} >"$OUTPUT_FILE"

	# Process events
	{
		echo "// ${CONTRACT}Topics contains event signatures for $CONTRACT"
		echo "type ${CONTRACT}Topics struct {"
	} >>"$OUTPUT_FILE"
	jq -c '.[] | select(.type == "event")' "$CONTRACT_DIR/$CONTRACT.abi" | while read -r EVENT; do
		EVENT_NAME=$(echo "$EVENT" | jq -r '.name')
		SIGNATURE="$EVENT_NAME($(echo "$EVENT" | jq -r '.inputs[].type' | paste -sd "," -))"
		TOPIC0=$(cast keccak "$SIGNATURE")
		echo "    $EVENT_NAME common.Hash \`json:\"$EVENT_NAME\"\` // $TOPIC0" >>"$OUTPUT_FILE"
	done
	# shellcheck disable=SC2129
	{
		echo "}"
		echo ""
	} >>"$OUTPUT_FILE"

	# Process methods
	echo "// ${CONTRACT}Methods contains method signatures for $CONTRACT" >>"$OUTPUT_FILE"
	echo "type ${CONTRACT}Methods struct {" >>"$OUTPUT_FILE"
	awk '
    BEGIN { seen[""] = 0 }
    /is a paid mutator transaction binding the contract method 0x[0-9a-f]{8}/ {
        method_name = ""; selector = ""
        if (split($0, parts, /\/\/ | is a paid/)) { method_name = parts[2] }
        if (match($0, /0x[0-9a-f]{8}/)) { selector = substr($0, RSTART, RLENGTH) }
        
        # Add braces for BSD awk compatibility
        if (method_name in seen) { next }
        
        signature = ""
        while ((getline line) > 0) {
            if (line ~ /Solidity: function/) {
                sub(/.*Solidity: function /, "", line)
                sub(/\).*/, ")", line)
                signature = line
                break
            }
        }
        if (method_name && selector && signature) {
            printf "    %s []byte `json:\"%s\"` // %s (%s)\n", 
                method_name, method_name, selector, signature
            seen[method_name] = 1
        }
    }
  ' "$CONTRACT_DIR/$CONTRACT.go" >>"$OUTPUT_FILE"
	{
		echo "}"
		echo ""
	} >>"$OUTPUT_FILE"

	# Add MethodNames struct
	echo "// ${CONTRACT}MethodNames contains method names with lowercase first letter" >>"$OUTPUT_FILE"
	echo "type ${CONTRACT}MethodNames struct {" >>"$OUTPUT_FILE"
	awk '
    BEGIN { seen[""] = 0 }
    /is a paid mutator transaction binding the contract method 0x[0-9a-f]{8}/ {
        method_name = ""
        if (split($0, parts, /\/\/ | is a paid/)) { method_name = parts[2] }
        
        if (method_name in seen) next
        seen[method_name] = 1
        
        # Lowercase first letter
        first = tolower(substr(method_name,1,1))
        rest = substr(method_name,2)
        printf "    %s string `json:\"%s\"`\n", method_name, method_name
    }
  ' "$CONTRACT_DIR/$CONTRACT.go" >>"$OUTPUT_FILE"
	{
		echo "}"
		echo ""
	} >>"$OUTPUT_FILE"

	# Add initialization functions
	echo "func Init${CONTRACT}Topics() ${CONTRACT}Topics {" >>"$OUTPUT_FILE"
	echo "    return ${CONTRACT}Topics{" >>"$OUTPUT_FILE"
	jq -c '.[] | select(.type == "event")' "$CONTRACT_DIR/$CONTRACT.abi" | while read -r EVENT; do
		EVENT_NAME=$(echo "$EVENT" | jq -r '.name')
		SIGNATURE="$EVENT_NAME($(echo "$EVENT" | jq -r '.inputs[].type' | paste -sd "," -))"
		TOPIC0=$(cast keccak "$SIGNATURE")
		echo "        $EVENT_NAME: common.HexToHash(\"$TOPIC0\")," >>"$OUTPUT_FILE"
	done
	# shellcheck disable=SC2129
	{
		echo "    }"
		echo "}"
		echo ""
		echo "func Init${CONTRACT}Methods() ${CONTRACT}Methods {"
		echo "    return ${CONTRACT}Methods{"
	} >>"$OUTPUT_FILE"

	awk '
    BEGIN { seen[""] = 0 }
    /is a paid mutator transaction binding the contract method 0x[0-9a-f]{8}/ {
        method_name = ""; selector = ""
        if (split($0, parts, /\/\/ | is a paid/)) { method_name = parts[2] }
        if (match($0, /0x[0-9a-f]{8}/)) { selector = substr($0, RSTART, RLENGTH) }
        
        if (method_name in seen) next
        seen[method_name] = 1
        
        # Convert selector to byte array
        split(substr(selector,3), arr, "")
        byte_array = sprintf("[]byte{0x%s%s, 0x%s%s, 0x%s%s, 0x%s%s}", 
            arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8])
        
        printf "        %s: %s,\n", method_name, byte_array
    }
  ' "$CONTRACT_DIR/$CONTRACT.go" >>"$OUTPUT_FILE"
	echo "    }" >>"$OUTPUT_FILE"
	echo "}" >>"$OUTPUT_FILE"

	echo "" >>"$OUTPUT_FILE"
	echo "func Init${CONTRACT}MethodNames() ${CONTRACT}MethodNames {" >>"$OUTPUT_FILE"
	echo "    return ${CONTRACT}MethodNames{" >>"$OUTPUT_FILE"
	awk '
    BEGIN { seen[""] = 0 }
    /is a paid mutator transaction binding the contract method 0x[0-9a-f]{8}/ {
        method_name = ""
        if (split($0, parts, /\/\/ | is a paid/)) { method_name = parts[2] }
        
        if (method_name in seen) next
        seen[method_name] = 1
        
        # Lowercase first letter
        first = tolower(substr(method_name,1,1))
        rest = substr(method_name,2)
        printf "        %s: \"%s\",\n", method_name, first rest
    }
  ' "$CONTRACT_DIR/$CONTRACT.go" >>"$OUTPUT_FILE"
	{
		echo "    }"
		echo "}"
	} >>"$OUTPUT_FILE"

	echo "✓ Generated ${CONTRACT}_extra.go"

	# Initialize markdown file with empty content
	true >"$OUTPUT_MD_FILE"

	# Extract events documentation
	EVENTS=$(jq -c '.[] | select(.type == "event")' "$CONTRACT_DIR/$CONTRACT.abi")
	if [[ -n "$EVENTS" ]]; then
		{
			echo "# ${CONTRACT} help generated by abisiggen.sh"
			echo ""
			echo "## Events:"
		} >>"$OUTPUT_MD_FILE"
		echo "$EVENTS" | while read -r EVENT; do
			EVENT_NAME=$(echo "$EVENT" | jq -r '.name')
			EVENT_INPUTS=$(echo "$EVENT" | jq -c '.inputs')

			SIGNATURE="$EVENT_NAME("
			SIGNATURE+=$(echo "$EVENT_INPUTS" | jq -r '.[] | .type' | paste -sd "," -)
			SIGNATURE+=")"

			# Keccak256 Topic0
			TOPIC0=$(cast keccak "$SIGNATURE")
			{
				echo "- Event: $EVENT_NAME"
				echo "   - Signature: $SIGNATURE"
				echo "   - topic0: $TOPIC0"
			} >>"$OUTPUT_MD_FILE"

			TOPIC_INDEX=1

			# Loop through inputs and dispatch them as indexed or part of data
			echo "$EVENT_INPUTS" | jq -c '.[]' | while read -r INPUT; do
				PARAM_TYPE=$(echo "$INPUT" | jq -r '.type')
				PARAM_NAME=$(echo "$INPUT" | jq -r '.name')
				IS_INDEXED=$(echo "$INPUT" | jq -r '.indexed')

				if [[ "$IS_INDEXED" == "true" ]]; then
					# Indexed -> to topic1, topic2, topic3
					echo "   - topic$TOPIC_INDEX: $PARAM_NAME ($PARAM_TYPE)" >>"$OUTPUT_MD_FILE"
					((TOPIC_INDEX++))
				else
					# Non-indexed -> are part of event data
					echo "   - Data: $PARAM_NAME ($PARAM_TYPE)" >>"$OUTPUT_MD_FILE"
				fi
			done
		done
		echo "" >>"$OUTPUT_MD_FILE"
	fi

	# Extract views documentation
	echo "## Views:" >>"$OUTPUT_MD_FILE"
	jq -r '.[] | 
    select(.type == "function" and (.stateMutability == "view" or .stateMutability == "pure")) | 
    "- " + .name + "\n" +
    if (.inputs | length > 0) then
        (.inputs | map("  - " + .name + ": " + .type) | join("\n"))
    else
        "  - params: none"
    end + "\n" +
    if (.outputs | length > 0) then
        (.outputs | map("  - returns: " + (if .name == "" then "unnamed" else .name end) + ": " + .type) | join("\n"))
    else
        "  - returns: void"
    end + "\n"' "$CONTRACT_DIR/$CONTRACT.abi" >>"$OUTPUT_MD_FILE"
done
